[{"video_id": "dG9zjKpRmdY", "transcript": " so in this uh recording Im going to um take a deep dive into swam which is a multi-agent framework that openi released uh last Friday so this is still an experimental and an educational framework and um so here it mentions its currently an experimental sample framework intended to explore ergonomic interfaces for multi-agent systems it is not intended to be used in production therefore has no official support right but uh the implementation is interesting uh it actually leverages function calling to stitch the agents together which Im not sure like if to me uh um so I when I look at multi-agent framework I always U think about uh microservices based architecture when I think about microservices architecture I think about two patterns the orchestration pattern and the and the choreography pattern the and and the stitching part of the agents in both this patterns are decoupled from the logic of the agents itself but in swarm um the way I I have seen it is like uh the function calling method of stitching the agents uh makes agents and the the stitching part of the agents all part of the same component uh which I I I feel is this little uh tight coupling between the two but its an interesting implementation right so Ill show uh how this uh implementation uh pattern Works uh when I show a uh example of uh agent swamp right so uh yeah so it focuses on making agent coordination and execution lightweight highly controllable and easily testable uh these are some of the um uh characteristics of the framework and there are two primitive obstructions that it uses one is uh the agent itself and handoffs U so the handoff is where I um where the function calling has been leveraged and agent obstruction is the obstruction of of the agent itself right this is interesting the um Define an agent uh in a very interesting way that an agent encompasses instructions and tools and can it at any point choose to hand off a conversation to another agent right um the other important thing that I wanted to uh highlight here is um that it it it is a stateless uh pattern and I wanted to find out okay that but yeah so here it says swamps run function is analogous to the chat. completions doc create function in the chat completion API it takes messages and returns messages and saves no State between calls importantly however it also handles agent function execution handoffs context variable uh references and can make and can take multiple TS before returning to the user so some of the arguments that the run method of this framework takes is the initial agent that needs to be called list of messages uh context variables um and well show an U use of this as well Maxton uh model override so if there is a default model if you want to override the default model default model is GPT 40 right we can um override the model um execute tools if fals interrupt execution and immediately returns tool calls message when an agent tries to call a function um we can turn on stream uh streaming or um and we can also run it in debug mode right the response F the response uh schema of uh the agent framework is message is the last agent on the active agent uh to handle a message and the context varibles um it also talks about the agent abstraction uh which encapsulates uh set of instructions and set of functions um so this is another interesting thing I noticed while its tempting to personify an agent as someone who does X it can also be used to represent a very specific specific workflow or step defined by a set of instruction and functions for example a set of steps a complex retrieval uh single step of data transformation Etc this allows agents to be composed into a network of agents workflows and tasks all represented by the same primitive right and these are the agent fills the name of the agent the model that uh to be used uh by the agent instructions uh functions and Tool choice and uh yeah so let lets um go into uh an example and uh see how um this is implemented uh before that I wanted to show this diagram uh to show like how actually the agents are stitched so when a query um is um targeted towards an agent right the agent uh uh Sayes if the if if uh it requires a function called right and if yes the function call Returns the next agent that needs to be handled right and the next agent then again checks if requires a function call if not then it ends a turn right so function calling is kind of um stitching the agents together so lets take a look at an example so here I um created this example two where I have uh three agents here right one agent is so this is the math expert agent you are an expert in maths and answer on the mathematics questions and then I have the physics expert uh agent and then I have the entry uh agent right the agent the first agent in the uh multi-agent system which is responsible to Route it to either the math agent or the physics agent uh based on the topic of the question right and to this agent I pass two functions ask math agent ask physics agents right this is the function calling I was talking about right and ask math agent is nothing but this function which returns a math agent and an Ask physics agent is nothing but um okay so ask physics agent this this function which returns a physics agent ask meth agent is the ask math agent function which returns a math agent right then I um okay so the client is uh this is I create a client of swamp so if I go here itll see that um this is this is what the client is right the get uh it has a get Chet completion uh method and um I wanted to show the default model also the default model is the is in the client. run the client. run is um coded it here right so if I click on it uh we should see the default model um where did I see the default model uh I think it is probably done in the swamp lets see okay or okay I I I I I know where it is like it is in the uh agent yeah is Agent obstruction right this is where the default model is right um and the default instructions are also there which can be uh overridden right in the Run um if I go inside the run now we can see how it works right so the active agent right this is the first agent right when um which gets uh called when I um give the prompt if Im passing any context variables that uh uh like we do here it is it does a deep copy of that right and puts into the history um and when the completion uh in the completion call the get chat completion if you remember this is uh the the Swarm um the the um function that was in uh when we instantiated the client as swarm right that it passes the active agent uh calls the uh completion message right if it is not a tool call right that means end of the turn right the it has come to the end of uh agent call right it breaks but if it is a tool call then it gets the next uh agent right this is where it is getting the next active agent and then uh calling that agent again right thats how it is working so let me run this and it will be clear I put some uh print statements within the um in this code to show how the flow works so so here I put the print active agent one this is the first agent wanted to also see the context how the context variables flow right and then here uh I put that t agent two right um and then finally since I have three agents right so active agent one um would be the like it will call the agent a and then based on whether physics or maths it will to the physics or the math let me run this so uh by the way the context variable right Im passing past conversation like U the conversation Im doing right Im pushing it to the context uh variable here by doing an context. append and here in my user query I I append that context variable so that when I when it aners it has the history of the uh the conversation history right so lets just say what is refraction right so here youll see the chat completion message right it passes or it has a function calling ask physics agent right right so this is um based on the topic right it says okay ask physics agent is a function called it hands it over to the physics exper right so I got the physics exper the physics expert there will be no function call that means it is the end of the turn right so if I go here yeah function call equal to n tool call equal to n that is the end of the turn right for that particular thing it answered me that reflection is a phenomenon that occurs when a uh wave such as light right what it gave me the answer right when I say what is T multiplied by 40 now it should hand it over to the math agent right so if I see now the chat completion agent the function call ask math agent right and the ask math agent gave me the answer the past history if you say it is um adding the so since I have uh concatenated the response. context variable right it it is uh and the context variable is where I am uh appending it uh appending the each response that I get in every turn right so it is uh storing the past conversation here right and if I see say what have I asked TR this sometimes sometimes it is able to actually refer to it sometimes it hallucinates but lets see yeah so see here it h ated what you have not asked any direct question so far the past includes an explanation about reflection kind of it still says it but in one of the um tries it actually said okay you ask this questions so probably some more uh prompt tuning will be required but it it was able to uh since I passed the uh history it is able to say the past conversation uh includes an uh explanation about reflection but no specific questions are mentioned which is partially true partially like I did ask about reflection but yeah I I asked the question also right so this is how it works um as as the uh GitHub also mentioned that this is still uh it is an experimental and educational type of framework um and uh my observation on it um is that uh the stitching part of the agents are still um tightly coupled within the framework uh if we follow a microservices based architecture my services and the orchestration of the services um needs to be decoupled so that we have more more control on changing uh or adapting to new changes and all right uh kind of the way langra does it right where langra is the orchestration um and I can orchestrate with a llm based agent or non-lm based agent using the uh orchestration its similar to how we used to do uh microservices based uh development uh where for choreography we used to use uh event hubs like Kafka or orchestration um tools like cunda or or Pega or any air flow right used to orchestrate the surfaces I will keep an eye on this particular framework and see how it develops right if there certain interesting things interesting features it gets I am going to uh keep an eye on it read about it and share uh the right time thank you bye-bye", "topics": ["SWAM framework", "multi-agent systems", "experimental framework", "ergonomic interfaces", "microservices architecture", "orchestration pattern", "choreography pattern", "tight coupling", "lightweight agent coordination", "agent handoffs", "stateless pattern", "function calling", "agent abstraction", "agent workflows", "agent instructions", "client implementation", "model overriding", "context variables", "agent execution", "chat completion API", "function call mechanism", "agent stitching", "educational framework", "prompt tuning", "observational notes on SWAM", "comparison with Langra", "microservices based development"]}]